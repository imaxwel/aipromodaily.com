# 多语言博客系统国际化方案

## 概述

本文档描述了如何将现有的英语/德语博客系统扩展为支持联合国6种官方语言（英语、中文、法语、西班牙语、俄语、阿拉伯语），并实现自动翻译功能。

## 1. 语言配置更新

### 1.1 更新 config/index.ts

需要在配置文件中添加所有支持的语言：

```typescript
// config/index.ts
export const config = {
  i18n: {
    enabled: true,
    locales: {
      en: {
        currency: "USD",
        label: "English",
        direction: "ltr", // 文字方向
      },
      zh: {
        currency: "CNY",
        label: "中文",
        direction: "ltr",
      },
      fr: {
        currency: "EUR",
        label: "Français",
        direction: "ltr",
      },
      es: {
        currency: "EUR",
        label: "Español",
        direction: "ltr",
      },
      ru: {
        currency: "RUB",
        label: "Русский",
        direction: "ltr",
      },
      ar: {
        currency: "USD",
        label: "العربية",
        direction: "rtl", // 阿拉伯语从右到左
      },
      de: {
        currency: "EUR",
        label: "Deutsch",
        direction: "ltr",
      },
    },
    defaultLocale: "en",
    defaultCurrency: "USD",
    localeCookieName: "NEXT_LOCALE",
  },
  // ... 其他配置
};
```

## 2. 博客内容目录结构

### 2.1 推荐的目录结构

```
apps/web/content/posts/
├── en/                     # 英文原始内容（主要语言）
│   ├── first-post.mdx
│   ├── second-post.mdx
│   └── ...
├── zh/                     # 中文翻译
│   ├── first-post.mdx
│   ├── second-post.mdx
│   └── ...
├── fr/                     # 法语翻译
│   ├── first-post.mdx
│   └── ...
├── es/                     # 西班牙语翻译
│   ├── first-post.mdx
│   └── ...
├── ru/                     # 俄语翻译
│   ├── first-post.mdx
│   └── ...
├── ar/                     # 阿拉伯语翻译
│   ├── first-post.mdx
│   └── ...
└── de/                     # 德语翻译
    ├── first-post.mdx
    └── ...
```

### 2.2 更新 content-collections.ts

```typescript
// apps/web/content-collections.ts
import { defineCollection, defineConfig } from "@content-collections/core";
import { compileMDX } from "@content-collections/mdx";
import rehypeShiki from "@shikijs/rehype";
import { config } from "../../config";

const supportedLocales = Object.keys(config.i18n.locales);

function getLocaleFromPath(path: string): string {
  const pathParts = path.split('/');
  const locale = pathParts[0];
  return supportedLocales.includes(locale) ? locale : config.i18n.defaultLocale;
}

function getSlugFromPath(path: string): string {
  const pathParts = path.split('/');
  // 如果路径包含locale，移除它
  if (supportedLocales.includes(pathParts[0])) {
    pathParts.shift();
  }
  return pathParts.join('/').replace(/\.mdx?$/, '');
}

const posts = defineCollection({
  name: "posts",
  directory: "content/posts",
  include: "**/*.{mdx,md}",
  schema: (z) => ({
    title: z.string(),
    date: z.string(),
    image: z.string().optional(),
    authorName: z.string(),
    authorImage: z.string().optional(),
    authorLink: z.string().optional(),
    excerpt: z.string().optional(),
    tags: z.array(z.string()),
    published: z.boolean(),
    // 添加语言相关字段
    originalLang: z.string().default("en"), // 原始语言
    isTranslation: z.boolean().default(false), // 是否为翻译版本
  }),
  transform: async (document, context) => {
    const body = await compileMDX(context, document, {
      rehypePlugins: [
        [
          rehypeShiki,
          {
            theme: "nord",
          },
        ],
      ],
    });

    const locale = getLocaleFromPath(document._meta.path);
    const slug = getSlugFromPath(document._meta.path);

    return {
      ...document,
      body,
      locale,
      slug,
      path: `${locale}/blog/${slug}`,
    };
  },
});

// ... 其他集合定义
```

## 3. 自动翻译系统

### 3.1 安装依赖

```bash
npm install --save-dev @google-cloud/translate openai glob gray-matter
# 或使用其他翻译API
```

### 3.2 创建翻译脚本

创建 `scripts/translate-posts.js`:

```javascript
// scripts/translate-posts.js
const fs = require('fs').promises;
const path = require('path');
const matter = require('gray-matter');
const { OpenAI } = require('openai');
// 或使用 Google Translate API
// const { Translate } = require('@google-cloud/translate').v2;

// 配置
const config = {
  sourceLocale: 'en',
  targetLocales: ['zh', 'fr', 'es', 'ru', 'ar', 'de'],
  contentDir: path.join(__dirname, '../apps/web/content/posts'),
  openaiApiKey: process.env.OPENAI_API_KEY,
};

// 初始化OpenAI
const openai = new OpenAI({
  apiKey: config.openaiApiKey,
});

// 语言名称映射
const languageNames = {
  en: 'English',
  zh: 'Chinese (Simplified)',
  fr: 'French',
  es: 'Spanish',
  ru: 'Russian',
  ar: 'Arabic',
  de: 'German',
};

/**
 * 使用OpenAI翻译内容
 */
async function translateWithOpenAI(text, targetLang, isMarkdown = true) {
  const systemPrompt = isMarkdown
    ? `You are a professional translator. Translate the following Markdown content from English to ${languageNames[targetLang]}. 
       Preserve all Markdown formatting, code blocks, links, and special syntax. 
       Do not translate code content inside code blocks, but you may translate code comments.
       Maintain the same structure and formatting as the original.`
    : `You are a professional translator. Translate the following text from English to ${languageNames[targetLang]}.`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: text }
      ],
      temperature: 0.3, // 较低的温度以获得更一致的翻译
    });

    return response.choices[0].message.content;
  } catch (error) {
    console.error(`翻译失败 (${targetLang}):`, error);
    throw error;
  }
}

/**
 * 翻译单个文件
 */
async function translateFile(filePath, targetLocale) {
  try {
    // 读取源文件
    const content = await fs.readFile(filePath, 'utf-8');
    const { data: frontmatter, content: markdownContent } = matter(content);

    // 翻译前置数据
    const translatedFrontmatter = { ...frontmatter };
    if (frontmatter.title) {
      translatedFrontmatter.title = await translateWithOpenAI(frontmatter.title, targetLocale, false);
    }
    if (frontmatter.excerpt) {
      translatedFrontmatter.excerpt = await translateWithOpenAI(frontmatter.excerpt, targetLocale, false);
    }
    // 标记为翻译版本
    translatedFrontmatter.originalLang = config.sourceLocale;
    translatedFrontmatter.isTranslation = true;

    // 翻译内容
    const translatedContent = await translateWithOpenAI(markdownContent, targetLocale, true);

    // 重新组合文件
    const newContent = matter.stringify(translatedContent, translatedFrontmatter);

    return newContent;
  } catch (error) {
    console.error(`翻译文件失败: ${filePath}`, error);
    throw error;
  }
}

/**
 * 主函数
 */
async function main() {
  console.log('🌍 开始批量翻译博客文章...\n');

  // 确保源目录存在
  const sourceDir = path.join(config.contentDir, config.sourceLocale);
  
  try {
    const files = await fs.readdir(sourceDir);
    const mdxFiles = files.filter(f => f.endsWith('.mdx') || f.endsWith('.md'));

    console.log(`找到 ${mdxFiles.length} 个文件需要翻译\n`);

    for (const targetLocale of config.targetLocales) {
      console.log(`\n📝 翻译到 ${languageNames[targetLocale]}...`);
      
      // 创建目标目录
      const targetDir = path.join(config.contentDir, targetLocale);
      await fs.mkdir(targetDir, { recursive: true });

      for (const file of mdxFiles) {
        const sourceFile = path.join(sourceDir, file);
        const targetFile = path.join(targetDir, file);

        // 检查目标文件是否已存在
        try {
          await fs.access(targetFile);
          console.log(`  ⏭️  跳过 ${file} (已存在)`);
          continue;
        } catch {
          // 文件不存在，继续翻译
        }

        console.log(`  📄 翻译 ${file}...`);
        
        try {
          const translatedContent = await translateFile(sourceFile, targetLocale);
          await fs.writeFile(targetFile, translatedContent);
          console.log(`  ✅ 完成 ${file}`);
        } catch (error) {
          console.error(`  ❌ 失败 ${file}: ${error.message}`);
        }

        // 添加延迟以避免API限制
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    console.log('\n✨ 翻译完成！');
  } catch (error) {
    console.error('❌ 翻译过程出错:', error);
    process.exit(1);
  }
}

// 运行脚本
if (require.main === module) {
  main();
}

module.exports = { translateFile, translateWithOpenAI };
```

### 3.3 创建增量翻译脚本

创建 `scripts/translate-new-posts.js`:

```javascript
// scripts/translate-new-posts.js
const fs = require('fs').promises;
const path = require('path');
const { translateFile } = require('./translate-posts');

const config = {
  sourceLocale: 'en',
  targetLocales: ['zh', 'fr', 'es', 'ru', 'ar', 'de'],
  contentDir: path.join(__dirname, '../apps/web/content/posts'),
};

/**
 * 查找需要翻译的新文件
 */
async function findNewPosts() {
  const sourceDir = path.join(config.contentDir, config.sourceLocale);
  const sourceFiles = await fs.readdir(sourceDir);
  const mdxFiles = sourceFiles.filter(f => f.endsWith('.mdx') || f.endsWith('.md'));

  const newFiles = [];

  for (const locale of config.targetLocales) {
    const targetDir = path.join(config.contentDir, locale);
    
    for (const file of mdxFiles) {
      const targetFile = path.join(targetDir, file);
      
      try {
        await fs.access(targetFile);
      } catch {
        // 文件不存在，需要翻译
        newFiles.push({ file, locale, source: path.join(sourceDir, file), target: targetFile });
      }
    }
  }

  return newFiles;
}

/**
 * 主函数
 */
async function main() {
  console.log('🔍 查找新的博客文章...\n');

  const newFiles = await findNewPosts();

  if (newFiles.length === 0) {
    console.log('✅ 所有文章都已翻译！');
    return;
  }

  console.log(`找到 ${newFiles.length} 个文件需要翻译\n`);

  for (const { file, locale, source, target } of newFiles) {
    console.log(`📝 翻译 ${file} 到 ${locale}...`);
    
    try {
      const targetDir = path.dirname(target);
      await fs.mkdir(targetDir, { recursive: true });
      
      const translatedContent = await translateFile(source, locale);
      await fs.writeFile(target, translatedContent);
      console.log(`✅ 完成\n`);
    } catch (error) {
      console.error(`❌ 失败: ${error.message}\n`);
    }

    // 添加延迟
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  console.log('✨ 所有翻译完成！');
}

if (require.main === module) {
  main();
}
```

## 4. Git Hooks 自动化

### 4.1 安装 husky

```bash
npm install --save-dev husky
npx husky install
```

### 4.2 创建 pre-commit hook

```bash
npx husky add .husky/pre-commit "npm run translate:check"
```

### 4.3 更新 package.json

```json
{
  "scripts": {
    "translate:all": "node scripts/translate-posts.js",
    "translate:new": "node scripts/translate-new-posts.js",
    "translate:check": "node scripts/check-translations.js",
    "post:new": "node scripts/create-post.js"
  }
}
```

## 5. 创建新文章的工作流

### 5.1 创建文章生成器脚本

创建 `scripts/create-post.js`:

```javascript
// scripts/create-post.js
const fs = require('fs').promises;
const path = require('path');
const readline = require('readline');
const { translateFile } = require('./translate-posts');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const question = (query) => new Promise((resolve) => rl.question(query, resolve));

async function createPost() {
  console.log('📝 创建新博客文章\n');

  // 收集信息
  const title = await question('文章标题: ');
  const slug = await question('URL slug (例如: my-new-post): ');
  const author = await question('作者名称: ');
  const tags = await question('标签 (用逗号分隔): ');
  const excerpt = await question('摘要: ');

  const date = new Date().toISOString().split('T')[0];
  
  // 创建前置数据
  const frontmatter = `---
title: "${title}"
date: "${date}"
authorName: "${author}"
tags: [${tags.split(',').map(t => `"${t.trim()}"`).join(', ')}]
excerpt: "${excerpt}"
published: false
---

`;

  const content = `${frontmatter}
# ${title}

在这里开始写你的文章内容...

## 介绍

你的介绍内容...

## 主要内容

你的主要内容...

## 结论

你的结论...
`;

  // 保存到英文目录
  const enDir = path.join(__dirname, '../apps/web/content/posts/en');
  await fs.mkdir(enDir, { recursive: true });
  
  const filePath = path.join(enDir, `${slug}.mdx`);
  await fs.writeFile(filePath, content);

  console.log(`\n✅ 文章已创建: ${filePath}`);

  const shouldTranslate = await question('\n是否立即翻译到其他语言? (y/n): ');
  
  if (shouldTranslate.toLowerCase() === 'y') {
    console.log('\n🌍 开始翻译...\n');
    
    const targetLocales = ['zh', 'fr', 'es', 'ru', 'ar', 'de'];
    
    for (const locale of targetLocales) {
      console.log(`翻译到 ${locale}...`);
      const targetDir = path.join(__dirname, '../apps/web/content/posts', locale);
      await fs.mkdir(targetDir, { recursive: true });
      
      const targetFile = path.join(targetDir, `${slug}.mdx`);
      const translatedContent = await translateFile(filePath, locale);
      await fs.writeFile(targetFile, translatedContent);
      console.log(`✅ 完成 ${locale}`);
    }
  }

  rl.close();
}

createPost().catch(console.error);
```

## 6. 前端实现

### 6.1 更新博客列表页面

```typescript
// apps/web/app/(marketing)/[locale]/blog/page.tsx
import { allPosts } from "content-collections";

export default async function BlogPage({ params }: { params: { locale: string } }) {
  // 过滤当前语言的文章
  const posts = allPosts
    .filter(post => post.locale === params.locale && post.published)
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

  // 获取其他语言版本的链接
  const getAlternateLinks = (slug: string) => {
    return allPosts
      .filter(post => post.slug === slug)
      .map(post => ({
        locale: post.locale,
        url: `/${post.locale}/blog/${slug}`
      }));
  };

  return (
    <div>
      {/* 博客列表渲染 */}
      {posts.map(post => (
        <article key={post._id}>
          {/* ... */}
          {/* 语言切换器 */}
          <div className="language-switcher">
            {getAlternateLinks(post.slug).map(link => (
              <a key={link.locale} href={link.url}>
                {link.locale.toUpperCase()}
              </a>
            ))}
          </div>
        </article>
      ))}
    </div>
  );
}
```

### 6.2 SEO 优化

```typescript
// apps/web/app/(marketing)/[locale]/blog/[slug]/page.tsx
export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const post = allPosts.find(
    p => p.slug === params.slug && p.locale === params.locale
  );

  if (!post) return {};

  // 获取其他语言版本
  const alternates = allPosts
    .filter(p => p.slug === params.slug)
    .reduce((acc, p) => ({
      ...acc,
      [p.locale]: `/${p.locale}/blog/${params.slug}`
    }), {});

  return {
    title: post.title,
    description: post.excerpt,
    alternates: {
      languages: alternates
    },
    openGraph: {
      title: post.title,
      description: post.excerpt,
      locale: params.locale,
      alternateLocale: Object.keys(alternates),
    },
  };
}
```

## 7. 部署和CI/CD

### 7.1 GitHub Actions 工作流

创建 `.github/workflows/translate-posts.yml`:

```yaml
name: Translate Blog Posts

on:
  push:
    paths:
      - 'apps/web/content/posts/en/**'
    branches:
      - main
  workflow_dispatch:

jobs:
  translate:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Translate new posts
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: npm run translate:new
    
    - name: Commit translations
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add apps/web/content/posts/
        git diff --staged --quiet || git commit -m "🌍 Auto-translate blog posts"
    
    - name: Push changes
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ github.ref }}
```

## 8. 性能优化

### 8.1 缓存策略

```typescript
// apps/web/lib/cache.ts
import { unstable_cache } from 'next/cache';

export const getCachedPosts = unstable_cache(
  async (locale: string) => {
    return allPosts
      .filter(post => post.locale === locale && post.published)
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  },
  ['posts'],
  {
    revalidate: 3600, // 1小时缓存
    tags: ['posts']
  }
);
```

### 8.2 静态生成

```typescript
// apps/web/app/(marketing)/[locale]/blog/[slug]/page.tsx
export async function generateStaticParams() {
  const locales = Object.keys(config.i18n.locales);
  const posts = allPosts.filter(post => post.published);
  
  return posts.map(post => ({
    locale: post.locale,
    slug: post.slug,
  }));
}
```

## 9. 翻译质量控制

### 9.1 人工审核流程

1. 自动翻译的文章默认设置 `published: false`
2. 创建审核工作流，人工检查后才发布
3. 使用 Git 分支管理翻译审核

### 9.2 翻译记忆库

创建翻译词汇表，确保专业术语的一致性：

```json
// translations/glossary.json
{
  "en": {
    "Next.js": "Next.js",
    "React": "React",
    "TypeScript": "TypeScript"
  },
  "zh": {
    "Next.js": "Next.js",
    "React": "React",
    "TypeScript": "TypeScript"
  },
  "fr": {
    "deployment": "déploiement",
    "framework": "framework"
  }
  // ...
}
```

## 10. 监控和分析

### 10.1 添加语言使用分析

```typescript
// apps/web/lib/analytics.ts
export function trackLanguageUsage(locale: string) {
  // 使用你的分析工具（如 Google Analytics, Plausible等）
  if (typeof window !== 'undefined') {
    window.gtag?.('event', 'language_selection', {
      language: locale,
    });
  }
}
```

## 总结

这个方案提供了一个完整的多语言博客系统实现，包括：

1. **自动化翻译流程** - 使用 AI API 自动翻译新文章
2. **版本控制集成** - Git hooks 和 GitHub Actions 自动化
3. **SEO 优化** - 多语言 SEO 标签和 sitemap
4. **性能优化** - 缓存和静态生成
5. **质量控制** - 人工审核和翻译记忆库
6. **监控分析** - 语言使用情况跟踪

### 下一步行动

1. 安装必要的依赖包
2. 配置翻译 API 密钥
3. 运行初始翻译脚本
4. 设置 CI/CD 工作流
5. 测试并优化翻译质量

这个系统可以确保你的博客内容能够高效地触达全球受众，同时保持高质量的翻译和良好的用户体验。
